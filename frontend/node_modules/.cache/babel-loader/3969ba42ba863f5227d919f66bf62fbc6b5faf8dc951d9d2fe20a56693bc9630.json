{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\sayda\\\\CascadeProjects\\\\beta-tech-support\\\\frontend\\\\src\\\\contexts\\\\NotificationContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useEffect } from 'react';\nimport { useAuth } from './AuthContext';\nimport { getSocket, onSocketEvent, offSocketEvent, joinUserRoom, joinTechnicianRoom } from '../services/socketService';\nimport { API_URL, USER_ENDPOINTS } from '../utils/apiConfig';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst NotificationContext = /*#__PURE__*/createContext();\nexport const useNotifications = () => {\n  _s();\n  return useContext(NotificationContext);\n};\n_s(useNotifications, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const NotificationProvider = ({\n  children\n}) => {\n  _s2();\n  const {\n    user\n  } = useAuth();\n  const [notifications, setNotifications] = useState([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n\n  // Initialize notifications when user logs in\n  useEffect(() => {\n    if (!user) {\n      setNotifications([]);\n      setUnreadCount(0);\n      return;\n    }\n\n    // Fetch existing notifications\n    const fetchNotifications = async () => {\n      try {\n        const response = await fetch(`${API_URL}/users/notifications`, {\n          headers: {\n            Authorization: `Bearer ${localStorage.getItem('token')}`\n          }\n        });\n        if (response.ok) {\n          const data = await response.json();\n          setNotifications(data);\n          setUnreadCount(data.filter(notif => !notif.read).length);\n        }\n      } catch (error) {\n        console.error('Error fetching notifications:', error);\n      }\n    };\n    fetchNotifications();\n\n    // Initialize socket connection\n    const socket = getSocket();\n\n    // Join user's personal room for notifications\n    if (user.userId) {\n      joinUserRoom(user.userId);\n    }\n\n    // If user is a technician, join the technician room\n    if (user.role === 'technician' || user.role === 'admin') {\n      joinTechnicianRoom();\n    }\n\n    // Handle new ticket notifications\n    const handleNewTicket = data => {\n      var _data$client;\n      const newNotification = {\n        id: `ticket_${Date.now()}`,\n        type: 'new_ticket',\n        ticketId: data.ticketId,\n        ticketNumber: data.ticketNumber,\n        message: `New ticket #${data.ticketNumber} created by ${((_data$client = data.client) === null || _data$client === void 0 ? void 0 : _data$client.name) || 'Client'}`,\n        timestamp: new Date().toISOString(),\n        read: false\n      };\n      setNotifications(prev => [newNotification, ...prev]);\n      setUnreadCount(prev => prev + 1);\n    };\n\n    // Handle ticket update notifications\n    const handleTicketUpdate = data => {\n      const newNotification = {\n        id: `update_${Date.now()}`,\n        type: 'ticket_update',\n        ticketId: data.ticketId,\n        ticketNumber: data.ticketNumber,\n        message: `Ticket #${data.ticketNumber} has been updated: ${data.updateType}`,\n        timestamp: new Date().toISOString(),\n        read: false\n      };\n      setNotifications(prev => [newNotification, ...prev]);\n      setUnreadCount(prev => prev + 1);\n    };\n\n    // Handle new message notifications\n    const handleNewMessage = data => {\n      var _data$sender;\n      // Only create notification if message is from someone else\n      if (((_data$sender = data.sender) === null || _data$sender === void 0 ? void 0 : _data$sender.id) !== user.userId) {\n        var _data$sender2;\n        const newNotification = {\n          id: `message_${Date.now()}`,\n          type: 'new_message',\n          ticketId: data.ticketId,\n          ticketNumber: data.ticketNumber,\n          message: `New message from ${((_data$sender2 = data.sender) === null || _data$sender2 === void 0 ? void 0 : _data$sender2.name) || 'User'} on ticket #${data.ticketNumber}`,\n          timestamp: new Date().toISOString(),\n          read: false\n        };\n        setNotifications(prev => [newNotification, ...prev]);\n        setUnreadCount(prev => prev + 1);\n      }\n    };\n\n    // Handle ticket assignment notifications\n    const handleTicketAssigned = data => {\n      const newNotification = {\n        id: `assigned_${Date.now()}`,\n        type: 'ticket_assigned',\n        ticketId: data.ticketId,\n        ticketNumber: data.ticketNumber,\n        message: `Ticket #${data.ticketNumber} has been assigned to you`,\n        timestamp: new Date().toISOString(),\n        read: false\n      };\n      setNotifications(prev => [newNotification, ...prev]);\n      setUnreadCount(prev => prev + 1);\n    };\n\n    // Handle ticket acceptance notifications for clients\n    const handleTicketAccepted = data => {\n      const newNotification = {\n        id: `accepted_${Date.now()}`,\n        type: 'ticket_accepted',\n        ticketId: data.ticketId,\n        ticketNumber: data.ticketNumber,\n        message: `Your ticket #${data.ticketNumber} has been accepted by ${data.technicianName}`,\n        timestamp: new Date().toISOString(),\n        read: false\n      };\n      setNotifications(prev => [newNotification, ...prev]);\n      setUnreadCount(prev => prev + 1);\n    };\n\n    // Register event listeners\n    onSocketEvent('new_ticket', handleNewTicket);\n    onSocketEvent('ticket_updated', handleTicketUpdate);\n    onSocketEvent('new_message', handleNewMessage);\n    onSocketEvent('ticket_assigned', handleTicketAssigned);\n    onSocketEvent('ticket_accepted', handleTicketAccepted);\n\n    // Cleanup function\n    return () => {\n      offSocketEvent('new_ticket', handleNewTicket);\n      offSocketEvent('ticket_updated', handleTicketUpdate);\n      offSocketEvent('new_message', handleNewMessage);\n      offSocketEvent('ticket_assigned', handleTicketAssigned);\n      offSocketEvent('ticket_accepted', handleTicketAccepted);\n    };\n  }, [user]);\n\n  // Mark notification as read\n  const markAsRead = notificationId => {\n    setNotifications(prev => prev.map(notif => notif.id === notificationId ? {\n      ...notif,\n      read: true\n    } : notif));\n    setUnreadCount(prev => Math.max(0, prev - 1));\n  };\n\n  // Mark all notifications as read\n  const markAllAsRead = () => {\n    setNotifications(prev => prev.map(notif => ({\n      ...notif,\n      read: true\n    })));\n    setUnreadCount(0);\n  };\n\n  // Remove a notification\n  const removeNotification = notificationId => {\n    const notification = notifications.find(n => n.id === notificationId);\n    setNotifications(prev => prev.filter(notif => notif.id !== notificationId));\n    if (notification && !notification.read) {\n      setUnreadCount(prev => Math.max(0, prev - 1));\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(NotificationContext.Provider, {\n    value: {\n      notifications,\n      unreadCount,\n      markAsRead,\n      markAllAsRead,\n      removeNotification\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 191,\n    columnNumber: 5\n  }, this);\n};\n_s2(NotificationProvider, \"CogDlZP32gwSK0s5FeDK512ezBY=\", false, function () {\n  return [useAuth];\n});\n_c = NotificationProvider;\nexport default NotificationProvider;\nvar _c;\n$RefreshReg$(_c, \"NotificationProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","useAuth","getSocket","onSocketEvent","offSocketEvent","joinUserRoom","joinTechnicianRoom","API_URL","USER_ENDPOINTS","jsxDEV","_jsxDEV","NotificationContext","useNotifications","_s","NotificationProvider","children","_s2","user","notifications","setNotifications","unreadCount","setUnreadCount","fetchNotifications","response","fetch","headers","Authorization","localStorage","getItem","ok","data","json","filter","notif","read","length","error","console","socket","userId","role","handleNewTicket","_data$client","newNotification","id","Date","now","type","ticketId","ticketNumber","message","client","name","timestamp","toISOString","prev","handleTicketUpdate","updateType","handleNewMessage","_data$sender","sender","_data$sender2","handleTicketAssigned","handleTicketAccepted","technicianName","markAsRead","notificationId","map","Math","max","markAllAsRead","removeNotification","notification","find","n","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/sayda/CascadeProjects/beta-tech-support/frontend/src/contexts/NotificationContext.js"],"sourcesContent":["import React, { createContext, useState, useContext, useEffect } from 'react';\nimport { useAuth } from './AuthContext';\nimport { \n  getSocket, \n  onSocketEvent, \n  offSocketEvent, \n  joinUserRoom,\n  joinTechnicianRoom\n} from '../services/socketService';\nimport { API_URL, USER_ENDPOINTS } from '../utils/apiConfig';\n\nconst NotificationContext = createContext();\n\nexport const useNotifications = () => useContext(NotificationContext);\n\nexport const NotificationProvider = ({ children }) => {\n  const { user } = useAuth();\n  const [notifications, setNotifications] = useState([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n\n  // Initialize notifications when user logs in\n  useEffect(() => {\n    if (!user) {\n      setNotifications([]);\n      setUnreadCount(0);\n      return;\n    }\n\n    // Fetch existing notifications\n    const fetchNotifications = async () => {\n      try {\n        const response = await fetch(`${API_URL}/users/notifications`, {\n          headers: {\n            Authorization: `Bearer ${localStorage.getItem('token')}`\n          }\n        });\n        \n        if (response.ok) {\n          const data = await response.json();\n          setNotifications(data);\n          setUnreadCount(data.filter(notif => !notif.read).length);\n        }\n      } catch (error) {\n        console.error('Error fetching notifications:', error);\n      }\n    };\n\n    fetchNotifications();\n\n    // Initialize socket connection\n    const socket = getSocket();\n\n    // Join user's personal room for notifications\n    if (user.userId) {\n      joinUserRoom(user.userId);\n    }\n\n    // If user is a technician, join the technician room\n    if (user.role === 'technician' || user.role === 'admin') {\n      joinTechnicianRoom();\n    }\n\n    // Handle new ticket notifications\n    const handleNewTicket = (data) => {\n      const newNotification = {\n        id: `ticket_${Date.now()}`,\n        type: 'new_ticket',\n        ticketId: data.ticketId,\n        ticketNumber: data.ticketNumber,\n        message: `New ticket #${data.ticketNumber} created by ${data.client?.name || 'Client'}`,\n        timestamp: new Date().toISOString(),\n        read: false\n      };\n\n      setNotifications(prev => [newNotification, ...prev]);\n      setUnreadCount(prev => prev + 1);\n    };\n\n    // Handle ticket update notifications\n    const handleTicketUpdate = (data) => {\n      const newNotification = {\n        id: `update_${Date.now()}`,\n        type: 'ticket_update',\n        ticketId: data.ticketId,\n        ticketNumber: data.ticketNumber,\n        message: `Ticket #${data.ticketNumber} has been updated: ${data.updateType}`,\n        timestamp: new Date().toISOString(),\n        read: false\n      };\n\n      setNotifications(prev => [newNotification, ...prev]);\n      setUnreadCount(prev => prev + 1);\n    };\n\n    // Handle new message notifications\n    const handleNewMessage = (data) => {\n      // Only create notification if message is from someone else\n      if (data.sender?.id !== user.userId) {\n        const newNotification = {\n          id: `message_${Date.now()}`,\n          type: 'new_message',\n          ticketId: data.ticketId,\n          ticketNumber: data.ticketNumber,\n          message: `New message from ${data.sender?.name || 'User'} on ticket #${data.ticketNumber}`,\n          timestamp: new Date().toISOString(),\n          read: false\n        };\n\n        setNotifications(prev => [newNotification, ...prev]);\n        setUnreadCount(prev => prev + 1);\n      }\n    };\n\n    // Handle ticket assignment notifications\n    const handleTicketAssigned = (data) => {\n      const newNotification = {\n        id: `assigned_${Date.now()}`,\n        type: 'ticket_assigned',\n        ticketId: data.ticketId,\n        ticketNumber: data.ticketNumber,\n        message: `Ticket #${data.ticketNumber} has been assigned to you`,\n        timestamp: new Date().toISOString(),\n        read: false\n      };\n\n      setNotifications(prev => [newNotification, ...prev]);\n      setUnreadCount(prev => prev + 1);\n    };\n\n    // Handle ticket acceptance notifications for clients\n    const handleTicketAccepted = (data) => {\n      const newNotification = {\n        id: `accepted_${Date.now()}`,\n        type: 'ticket_accepted',\n        ticketId: data.ticketId,\n        ticketNumber: data.ticketNumber,\n        message: `Your ticket #${data.ticketNumber} has been accepted by ${data.technicianName}`,\n        timestamp: new Date().toISOString(),\n        read: false\n      };\n\n      setNotifications(prev => [newNotification, ...prev]);\n      setUnreadCount(prev => prev + 1);\n    };\n\n    // Register event listeners\n    onSocketEvent('new_ticket', handleNewTicket);\n    onSocketEvent('ticket_updated', handleTicketUpdate);\n    onSocketEvent('new_message', handleNewMessage);\n    onSocketEvent('ticket_assigned', handleTicketAssigned);\n    onSocketEvent('ticket_accepted', handleTicketAccepted);\n\n    // Cleanup function\n    return () => {\n      offSocketEvent('new_ticket', handleNewTicket);\n      offSocketEvent('ticket_updated', handleTicketUpdate);\n      offSocketEvent('new_message', handleNewMessage);\n      offSocketEvent('ticket_assigned', handleTicketAssigned);\n      offSocketEvent('ticket_accepted', handleTicketAccepted);\n    };\n  }, [user]);\n\n  // Mark notification as read\n  const markAsRead = (notificationId) => {\n    setNotifications(prev => \n      prev.map(notif => \n        notif.id === notificationId ? { ...notif, read: true } : notif\n      )\n    );\n    setUnreadCount(prev => Math.max(0, prev - 1));\n  };\n\n  // Mark all notifications as read\n  const markAllAsRead = () => {\n    setNotifications(prev => \n      prev.map(notif => ({ ...notif, read: true }))\n    );\n    setUnreadCount(0);\n  };\n\n  // Remove a notification\n  const removeNotification = (notificationId) => {\n    const notification = notifications.find(n => n.id === notificationId);\n    setNotifications(prev => prev.filter(notif => notif.id !== notificationId));\n    if (notification && !notification.read) {\n      setUnreadCount(prev => Math.max(0, prev - 1));\n    }\n  };\n\n  return (\n    <NotificationContext.Provider\n      value={{\n        notifications,\n        unreadCount,\n        markAsRead,\n        markAllAsRead,\n        removeNotification\n      }}\n    >\n      {children}\n    </NotificationContext.Provider>\n  );\n};\n\nexport default NotificationProvider;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}