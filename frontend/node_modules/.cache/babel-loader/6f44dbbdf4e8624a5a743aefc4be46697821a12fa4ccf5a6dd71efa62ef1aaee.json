{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\sayda\\\\CascadeProjects\\\\beta-tech-support\\\\frontend\\\\src\\\\contexts\\\\TicketContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useCallback, useEffect } from 'react';\nimport axios from 'axios';\nimport { TICKET_ENDPOINTS, USER_ENDPOINTS, API_URL } from '../utils/apiConfig';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst TicketContext = /*#__PURE__*/createContext();\nexport const useTickets = () => {\n  _s();\n  const context = useContext(TicketContext);\n  if (!context) {\n    throw new Error('useTickets must be used within a TicketProvider');\n  }\n  return context;\n};\n_s(useTickets, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const TicketProvider = ({\n  children\n}) => {\n  _s2();\n  const [tickets, setTickets] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [technicians, setTechnicians] = useState([]);\n  const [technicianLoading, setTechnicianLoading] = useState(false);\n\n  // Fetch all technicians - Define this first since it's used in useEffect\n  const fetchTechnicians = useCallback(async () => {\n    setTechnicianLoading(true);\n    try {\n      console.log('Fetching technicians from:', USER_ENDPOINTS.GET_TECHNICIANS);\n      const token = localStorage.getItem('token');\n      if (!token) {\n        console.error('No token found for technician fetch');\n        setTechnicianLoading(false);\n        return [];\n      }\n      const response = await axios.get(USER_ENDPOINTS.GET_TECHNICIANS, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      console.log('Technicians API response status:', response.status);\n      console.log('Technicians fetched:', response.data);\n\n      // Ensure we're dealing with an array of technicians\n      const techData = Array.isArray(response.data) ? response.data : [];\n      setTechnicians(techData);\n      return techData;\n    } catch (err) {\n      var _err$response;\n      console.error('Error fetching technicians:', err);\n      console.error('Error response:', (_err$response = err.response) === null || _err$response === void 0 ? void 0 : _err$response.data);\n      return [];\n    } finally {\n      setTechnicianLoading(false);\n    }\n  }, []);\n\n  // Fetch all tickets\n  const fetchTickets = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      console.log('Fetching tickets from:', TICKET_ENDPOINTS.GET_ALL);\n      const token = localStorage.getItem('token');\n      if (!token) {\n        console.error('No token found for ticket fetch');\n        setError('Authentication required');\n        setLoading(false);\n        return [];\n      }\n      const response = await axios.get(TICKET_ENDPOINTS.GET_ALL, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n\n      // Log the raw response for debugging\n      console.log('Raw tickets response:', response.data);\n\n      // Ensure we're dealing with an array of tickets\n      let ticketsData;\n      if (Array.isArray(response.data)) {\n        ticketsData = response.data;\n      } else if (response.data.tickets && Array.isArray(response.data.tickets)) {\n        ticketsData = response.data.tickets;\n      } else if (typeof response.data === 'object') {\n        // If it's an object, try to extract tickets from any property that is an array\n        const possibleTicketsArray = Object.values(response.data).find(val => Array.isArray(val));\n        ticketsData = possibleTicketsArray || [];\n      } else {\n        ticketsData = [];\n      }\n      console.log('Processed tickets data:', ticketsData);\n      console.log('Number of tickets found:', ticketsData.length);\n      setTickets(ticketsData);\n      return ticketsData;\n    } catch (err) {\n      var _err$response2;\n      console.error('Error fetching tickets:', err);\n      console.error('Error response:', (_err$response2 = err.response) === null || _err$response2 === void 0 ? void 0 : _err$response2.data);\n      setError(err.message || 'Failed to fetch tickets');\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Initial data fetch\n  useEffect(() => {\n    console.log('TicketContext mounted, fetching initial data...');\n    const initializeData = async () => {\n      await Promise.all([fetchTickets(), fetchTechnicians()]);\n    };\n    initializeData();\n  }, [fetchTickets, fetchTechnicians]);\n\n  // Add a new ticket to the local state\n  const addTicket = useCallback(newTicket => {\n    console.log('Adding new ticket to context:', newTicket);\n    setTickets(prevTickets => {\n      // Ensure we don't add duplicate tickets\n      const ticketExists = prevTickets.some(t => t._id === newTicket._id);\n      if (ticketExists) {\n        console.log('Ticket already exists in state, updating...');\n        return prevTickets.map(t => t._id === newTicket._id ? newTicket : t);\n      }\n      console.log('Adding new ticket to state...');\n      return [newTicket, ...prevTickets];\n    });\n  }, []);\n\n  // Create a new ticket\n  const createTicket = useCallback(async ticketData => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await axios.post(TICKET_ENDPOINTS.CREATE, ticketData, {\n        headers: {\n          Authorization: `Bearer ${localStorage.getItem('token')}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      if (response.data.ticket) {\n        addTicket(response.data.ticket);\n      }\n      return response.data;\n    } catch (err) {\n      console.error('Error creating ticket:', err);\n      setError(err.message || 'Failed to create ticket');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [addTicket]);\n\n  // Find user by username and get their ID\n  const findUserByUsername = useCallback(async username => {\n    try {\n      const response = await axios.get(`${API_URL}/users/find?username=${username}`, {\n        headers: {\n          Authorization: `Bearer ${localStorage.getItem('token')}`\n        }\n      });\n      return response.data;\n    } catch (err) {\n      console.error('Error finding user:', err);\n      throw err;\n    }\n  }, []);\n\n  // Assign ticket to a technician\n  const assignTicket = useCallback(async (ticketId, technicianId) => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await axios.patch(TICKET_ENDPOINTS.ASSIGN(ticketId), {\n        technicianId\n      }, {\n        headers: {\n          Authorization: `Bearer ${localStorage.getItem('token')}`,\n          'Content-Type': 'application/json'\n        }\n      });\n\n      // Find technician details\n      const technicianDetails = technicians.find(tech => tech._id === technicianId) || {\n        _id: technicianId,\n        username: 'Unknown'\n      };\n\n      // Update the ticket in our local state\n      setTickets(prevTickets => prevTickets.map(ticket => ticket._id === ticketId ? {\n        ...ticket,\n        assignedTo: response.data.assignedTo || technicianDetails,\n        status: 'in_progress'\n      } : ticket));\n      return response.data;\n    } catch (err) {\n      console.error(`Error assigning ticket ${ticketId}:`, err);\n      setError(err.message || `Failed to assign ticket ${ticketId}`);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [technicians]);\n\n  // Assign all unassigned tickets to a specified technician\n  const assignAllUnassignedTickets = useCallback(async username => {\n    setLoading(true);\n    setError(null);\n    try {\n      const user = await findUserByUsername(username);\n      if (!user || !user._id) {\n        throw new Error(`User ${username} not found`);\n      }\n      const unassignedTickets = tickets.filter(ticket => !ticket.assignedTo);\n      if (unassignedTickets.length === 0) {\n        return {\n          message: 'No unassigned tickets found',\n          assignedCount: 0\n        };\n      }\n      await Promise.all(unassignedTickets.map(ticket => assignTicket(ticket._id, user._id)));\n      await fetchTickets();\n      return {\n        message: `Successfully assigned ${unassignedTickets.length} tickets to ${username}`,\n        assignedCount: unassignedTickets.length\n      };\n    } catch (err) {\n      console.error('Error assigning all unassigned tickets:', err);\n      setError(err.message || 'Failed to assign tickets');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [tickets, findUserByUsername, assignTicket, fetchTickets]);\n  const value = {\n    tickets,\n    loading,\n    error,\n    fetchTickets,\n    addTicket,\n    createTicket,\n    assignTicket,\n    assignAllUnassignedTickets,\n    technicians,\n    technicianLoading,\n    fetchTechnicians\n  };\n  return /*#__PURE__*/_jsxDEV(TicketContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 270,\n    columnNumber: 10\n  }, this);\n};\n_s2(TicketProvider, \"bDgUyOl9AU6Hxgx66L9Ggac4br0=\");\n_c = TicketProvider;\nvar _c;\n$RefreshReg$(_c, \"TicketProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","useEffect","axios","TICKET_ENDPOINTS","USER_ENDPOINTS","API_URL","jsxDEV","_jsxDEV","TicketContext","useTickets","_s","context","Error","TicketProvider","children","_s2","tickets","setTickets","loading","setLoading","error","setError","technicians","setTechnicians","technicianLoading","setTechnicianLoading","fetchTechnicians","console","log","GET_TECHNICIANS","token","localStorage","getItem","response","get","headers","Authorization","status","data","techData","Array","isArray","err","_err$response","fetchTickets","GET_ALL","ticketsData","possibleTicketsArray","Object","values","find","val","length","_err$response2","message","initializeData","Promise","all","addTicket","newTicket","prevTickets","ticketExists","some","t","_id","map","createTicket","ticketData","post","CREATE","ticket","findUserByUsername","username","assignTicket","ticketId","technicianId","patch","ASSIGN","technicianDetails","tech","assignedTo","assignAllUnassignedTickets","user","unassignedTickets","filter","assignedCount","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/sayda/CascadeProjects/beta-tech-support/frontend/src/contexts/TicketContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, useEffect } from 'react';\nimport axios from 'axios';\nimport { TICKET_ENDPOINTS, USER_ENDPOINTS, API_URL } from '../utils/apiConfig';\n\nconst TicketContext = createContext();\n\nexport const useTickets = () => {\n  const context = useContext(TicketContext);\n  if (!context) {\n    throw new Error('useTickets must be used within a TicketProvider');\n  }\n  return context;\n};\n\nexport const TicketProvider = ({ children }) => {\n  const [tickets, setTickets] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [technicians, setTechnicians] = useState([]);\n  const [technicianLoading, setTechnicianLoading] = useState(false);\n\n  // Fetch all technicians - Define this first since it's used in useEffect\n  const fetchTechnicians = useCallback(async () => {\n    setTechnicianLoading(true);\n    try {\n      console.log('Fetching technicians from:', USER_ENDPOINTS.GET_TECHNICIANS);\n      const token = localStorage.getItem('token');\n      \n      if (!token) {\n        console.error('No token found for technician fetch');\n        setTechnicianLoading(false);\n        return [];\n      }\n\n      const response = await axios.get(USER_ENDPOINTS.GET_TECHNICIANS, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      \n      console.log('Technicians API response status:', response.status);\n      console.log('Technicians fetched:', response.data);\n      \n      // Ensure we're dealing with an array of technicians\n      const techData = Array.isArray(response.data) ? response.data : [];\n      setTechnicians(techData);\n      return techData;\n    } catch (err) {\n      console.error('Error fetching technicians:', err);\n      console.error('Error response:', err.response?.data);\n      return [];\n    } finally {\n      setTechnicianLoading(false);\n    }\n  }, []);\n\n  // Fetch all tickets\n  const fetchTickets = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      console.log('Fetching tickets from:', TICKET_ENDPOINTS.GET_ALL);\n      const token = localStorage.getItem('token');\n      \n      if (!token) {\n        console.error('No token found for ticket fetch');\n        setError('Authentication required');\n        setLoading(false);\n        return [];\n      }\n\n      const response = await axios.get(TICKET_ENDPOINTS.GET_ALL, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      \n      // Log the raw response for debugging\n      console.log('Raw tickets response:', response.data);\n      \n      // Ensure we're dealing with an array of tickets\n      let ticketsData;\n      if (Array.isArray(response.data)) {\n        ticketsData = response.data;\n      } else if (response.data.tickets && Array.isArray(response.data.tickets)) {\n        ticketsData = response.data.tickets;\n      } else if (typeof response.data === 'object') {\n        // If it's an object, try to extract tickets from any property that is an array\n        const possibleTicketsArray = Object.values(response.data).find(val => Array.isArray(val));\n        ticketsData = possibleTicketsArray || [];\n      } else {\n        ticketsData = [];\n      }\n      \n      console.log('Processed tickets data:', ticketsData);\n      console.log('Number of tickets found:', ticketsData.length);\n      \n      setTickets(ticketsData);\n      return ticketsData;\n    } catch (err) {\n      console.error('Error fetching tickets:', err);\n      console.error('Error response:', err.response?.data);\n      setError(err.message || 'Failed to fetch tickets');\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Initial data fetch\n  useEffect(() => {\n    console.log('TicketContext mounted, fetching initial data...');\n    const initializeData = async () => {\n      await Promise.all([fetchTickets(), fetchTechnicians()]);\n    };\n    initializeData();\n  }, [fetchTickets, fetchTechnicians]);\n\n  // Add a new ticket to the local state\n  const addTicket = useCallback((newTicket) => {\n    console.log('Adding new ticket to context:', newTicket);\n    setTickets(prevTickets => {\n      // Ensure we don't add duplicate tickets\n      const ticketExists = prevTickets.some(t => t._id === newTicket._id);\n      if (ticketExists) {\n        console.log('Ticket already exists in state, updating...');\n        return prevTickets.map(t => t._id === newTicket._id ? newTicket : t);\n      }\n      console.log('Adding new ticket to state...');\n      return [newTicket, ...prevTickets];\n    });\n  }, []);\n\n  // Create a new ticket\n  const createTicket = useCallback(async (ticketData) => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await axios.post(\n        TICKET_ENDPOINTS.CREATE,\n        ticketData,\n        {\n          headers: {\n            Authorization: `Bearer ${localStorage.getItem('token')}`,\n            'Content-Type': 'application/json'\n          }\n        }\n      );\n      \n      if (response.data.ticket) {\n        addTicket(response.data.ticket);\n      }\n      \n      return response.data;\n    } catch (err) {\n      console.error('Error creating ticket:', err);\n      setError(err.message || 'Failed to create ticket');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [addTicket]);\n\n  // Find user by username and get their ID\n  const findUserByUsername = useCallback(async (username) => {\n    try {\n      const response = await axios.get(`${API_URL}/users/find?username=${username}`, {\n        headers: {\n          Authorization: `Bearer ${localStorage.getItem('token')}`\n        }\n      });\n      return response.data;\n    } catch (err) {\n      console.error('Error finding user:', err);\n      throw err;\n    }\n  }, []);\n\n  // Assign ticket to a technician\n  const assignTicket = useCallback(async (ticketId, technicianId) => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await axios.patch(\n        TICKET_ENDPOINTS.ASSIGN(ticketId),\n        { technicianId },\n        {\n          headers: {\n            Authorization: `Bearer ${localStorage.getItem('token')}`,\n            'Content-Type': 'application/json'\n          }\n        }\n      );\n\n      // Find technician details\n      const technicianDetails = technicians.find(tech => tech._id === technicianId) || {\n        _id: technicianId,\n        username: 'Unknown'\n      };\n\n      // Update the ticket in our local state\n      setTickets(prevTickets => \n        prevTickets.map(ticket => \n          ticket._id === ticketId ? {\n            ...ticket, \n            assignedTo: response.data.assignedTo || technicianDetails,\n            status: 'in_progress'\n          } : ticket\n        )\n      );\n\n      return response.data;\n    } catch (err) {\n      console.error(`Error assigning ticket ${ticketId}:`, err);\n      setError(err.message || `Failed to assign ticket ${ticketId}`);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [technicians]);\n\n  // Assign all unassigned tickets to a specified technician\n  const assignAllUnassignedTickets = useCallback(async (username) => {\n    setLoading(true);\n    setError(null);\n    try {\n      const user = await findUserByUsername(username);\n      if (!user || !user._id) {\n        throw new Error(`User ${username} not found`);\n      }\n      \n      const unassignedTickets = tickets.filter(ticket => !ticket.assignedTo);\n      if (unassignedTickets.length === 0) {\n        return { message: 'No unassigned tickets found', assignedCount: 0 };\n      }\n      \n      await Promise.all(unassignedTickets.map(ticket => \n        assignTicket(ticket._id, user._id)\n      ));\n      \n      await fetchTickets();\n      \n      return { \n        message: `Successfully assigned ${unassignedTickets.length} tickets to ${username}`,\n        assignedCount: unassignedTickets.length \n      };\n    } catch (err) {\n      console.error('Error assigning all unassigned tickets:', err);\n      setError(err.message || 'Failed to assign tickets');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [tickets, findUserByUsername, assignTicket, fetchTickets]);\n\n  const value = {\n    tickets,\n    loading,\n    error,\n    fetchTickets,\n    addTicket,\n    createTicket,\n    assignTicket,\n    assignAllUnassignedTickets,\n    technicians,\n    technicianLoading,\n    fetchTechnicians\n  };\n\n  return <TicketContext.Provider value={value}>{children}</TicketContext.Provider>;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}