{"ast":null,"code":"import io from 'socket.io-client';\nimport { SOCKET_URL } from '../utils/apiConfig';\nlet socket = null;\nlet socketListeners = [];\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\n\n/**\n * Get or initialize the socket connection\n * @param {string} token - Authentication token\n * @returns {Socket} The socket instance\n */\nexport const getSocket = token => {\n  if (!socket) {\n    // Create new socket connection\n    socket = io(SOCKET_URL, {\n      reconnectionAttempts: MAX_RECONNECT_ATTEMPTS,\n      auth: {\n        token: token || localStorage.getItem('token')\n      }\n    });\n    console.log('Socket connection established to:', SOCKET_URL);\n\n    // Setup socket event handlers\n    setupSocketEventHandlers();\n\n    // Apply any registered listeners\n    socketListeners.forEach(({\n      event,\n      callback\n    }) => {\n      socket.on(event, callback);\n    });\n  }\n  return socket;\n};\n\n/**\n * Setup socket event handlers for connection events\n */\nconst setupSocketEventHandlers = () => {\n  if (!socket) return;\n  socket.on('connect', () => {\n    console.log('Socket connected successfully');\n    reconnectAttempts = 0;\n  });\n  socket.on('connect_error', error => {\n    console.error('Socket connection error:', error.message);\n    reconnectAttempts++;\n    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n      console.error('Max reconnection attempts reached. Please check your connection.');\n    }\n  });\n  socket.on('disconnect', reason => {\n    console.log('Socket disconnected:', reason);\n    if (reason === 'io server disconnect') {\n      // The server has forcefully disconnected the socket\n      console.log('Server disconnected the socket. Attempting to reconnect...');\n      socket.connect();\n    }\n  });\n  socket.on('error', error => {\n    console.error('Socket error:', error);\n  });\n};\n\n/**\n * Register an event listener that persists across reconnections\n * @param {string} event - The event name\n * @param {function} callback - The callback function\n */\nexport const onSocketEvent = (event, callback) => {\n  // Store the listener for reconnections\n  socketListeners.push({\n    event,\n    callback\n  });\n\n  // If socket exists, add the listener immediately\n  if (socket) {\n    socket.on(event, callback);\n  }\n};\n\n/**\n * Remove a specific event listener\n * @param {string} event - The event name\n * @param {function} callback - The callback function to remove\n */\nexport const offSocketEvent = (event, callback) => {\n  // Remove from our tracking array\n  socketListeners = socketListeners.filter(listener => !(listener.event === event && listener.callback === callback));\n\n  // Remove from socket if it exists\n  if (socket) {\n    socket.off(event, callback);\n  }\n};\n\n/**\n * Close the socket connection\n */\nexport const closeSocket = () => {\n  if (socket) {\n    socket.disconnect();\n    socket = null;\n    socketListeners = [];\n    reconnectAttempts = 0;\n    console.log('Socket connection closed');\n  }\n};\n\n/**\n * Join a user's personal room for notifications\n * @param {string} userId - The user ID to join\n */\nexport const joinUserRoom = userId => {\n  try {\n    const socket = getSocket();\n    socket.emit('joinUserRoom', userId);\n  } catch (error) {\n    console.error('Error joining user room:', error);\n  }\n};\n\n/**\n * Join a ticket room\n * @param {string} ticketId - The ticket ID to join\n */\nexport const joinTicketRoom = ticketId => {\n  try {\n    const socket = getSocket();\n    socket.emit('join_ticket', ticketId);\n  } catch (error) {\n    console.error('Error joining ticket room:', error);\n  }\n};\n\n/**\n * Leave a ticket room\n * @param {string} ticketId - The ticket ID to leave\n */\nexport const leaveTicketRoom = ticketId => {\n  try {\n    const socket = getSocket();\n    socket.emit('leave_ticket', ticketId);\n  } catch (error) {\n    console.error('Error leaving ticket room:', error);\n  }\n};\n\n/**\n * Join the technician room\n */\nexport const joinTechnicianRoom = () => {\n  try {\n    const socket = getSocket();\n    socket.emit('joinTechnicianRoom');\n  } catch (error) {\n    console.error('Error joining technician room:', error);\n  }\n};\n\n/**\n * Leave the technician room\n */\nexport const leaveTechnicianRoom = () => {\n  try {\n    const socket = getSocket();\n    socket.emit('leaveTechnicianRoom');\n  } catch (error) {\n    console.error('Error leaving technician room:', error);\n  }\n};\n\n/**\n * Send a message to a ticket room\n * @param {Object} data - The message data\n * @returns {Promise} - Resolves when message is sent or rejects on error\n */\nexport const sendTicketMessage = data => {\n  return new Promise((resolve, reject) => {\n    try {\n      const socket = getSocket();\n      socket.emit('ticket_message', data);\n      resolve();\n    } catch (error) {\n      console.error('Error sending ticket message:', error);\n      reject(error);\n    }\n  });\n};\n\n/**\n * Accept a ticket as a technician\n * @param {Object} data - The ticket acceptance data\n * @returns {Promise} - Resolves when ticket is accepted or rejects on error\n */\nexport const acceptTicket = data => {\n  return new Promise((resolve, reject) => {\n    try {\n      const socket = getSocket();\n      socket.emit('accept_ticket', data);\n      resolve();\n    } catch (error) {\n      console.error('Error accepting ticket:', error);\n      reject(error);\n    }\n  });\n};\n\n/**\n * Check if socket is connected\n * @returns {boolean} - True if socket is connected, false otherwise\n */\nexport const isSocketConnected = () => {\n  return socket && socket.connected;\n};\n\n/**\n * Reconnect the socket if disconnected\n * @param {string} token - Authentication token\n */\nexport const reconnectSocket = token => {\n  if (socket && !socket.connected) {\n    socket.connect();\n  } else if (!socket) {\n    getSocket(token);\n  }\n};","map":{"version":3,"names":["io","SOCKET_URL","socket","socketListeners","reconnectAttempts","MAX_RECONNECT_ATTEMPTS","getSocket","token","reconnectionAttempts","auth","localStorage","getItem","console","log","setupSocketEventHandlers","forEach","event","callback","on","error","message","reason","connect","onSocketEvent","push","offSocketEvent","filter","listener","off","closeSocket","disconnect","joinUserRoom","userId","emit","joinTicketRoom","ticketId","leaveTicketRoom","joinTechnicianRoom","leaveTechnicianRoom","sendTicketMessage","data","Promise","resolve","reject","acceptTicket","isSocketConnected","connected","reconnectSocket"],"sources":["C:/Users/sayda/CascadeProjects/beta-tech-support/frontend/src/services/socketService.js"],"sourcesContent":["import io from 'socket.io-client';\nimport { SOCKET_URL } from '../utils/apiConfig';\n\nlet socket = null;\nlet socketListeners = [];\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\n\n/**\n * Get or initialize the socket connection\n * @param {string} token - Authentication token\n * @returns {Socket} The socket instance\n */\nexport const getSocket = (token) => {\n  if (!socket) {\n    // Create new socket connection\n    socket = io(SOCKET_URL, {\n      reconnectionAttempts: MAX_RECONNECT_ATTEMPTS,\n      auth: { token: token || localStorage.getItem('token') }\n    });\n    \n    console.log('Socket connection established to:', SOCKET_URL);\n    \n    // Setup socket event handlers\n    setupSocketEventHandlers();\n    \n    // Apply any registered listeners\n    socketListeners.forEach(({ event, callback }) => {\n      socket.on(event, callback);\n    });\n  }\n  return socket;\n};\n\n/**\n * Setup socket event handlers for connection events\n */\nconst setupSocketEventHandlers = () => {\n  if (!socket) return;\n  \n  socket.on('connect', () => {\n    console.log('Socket connected successfully');\n    reconnectAttempts = 0;\n  });\n  \n  socket.on('connect_error', (error) => {\n    console.error('Socket connection error:', error.message);\n    reconnectAttempts++;\n    \n    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n      console.error('Max reconnection attempts reached. Please check your connection.');\n    }\n  });\n  \n  socket.on('disconnect', (reason) => {\n    console.log('Socket disconnected:', reason);\n    \n    if (reason === 'io server disconnect') {\n      // The server has forcefully disconnected the socket\n      console.log('Server disconnected the socket. Attempting to reconnect...');\n      socket.connect();\n    }\n  });\n  \n  socket.on('error', (error) => {\n    console.error('Socket error:', error);\n  });\n};\n\n/**\n * Register an event listener that persists across reconnections\n * @param {string} event - The event name\n * @param {function} callback - The callback function\n */\nexport const onSocketEvent = (event, callback) => {\n  // Store the listener for reconnections\n  socketListeners.push({ event, callback });\n  \n  // If socket exists, add the listener immediately\n  if (socket) {\n    socket.on(event, callback);\n  }\n};\n\n/**\n * Remove a specific event listener\n * @param {string} event - The event name\n * @param {function} callback - The callback function to remove\n */\nexport const offSocketEvent = (event, callback) => {\n  // Remove from our tracking array\n  socketListeners = socketListeners.filter(\n    listener => !(listener.event === event && listener.callback === callback)\n  );\n  \n  // Remove from socket if it exists\n  if (socket) {\n    socket.off(event, callback);\n  }\n};\n\n/**\n * Close the socket connection\n */\nexport const closeSocket = () => {\n  if (socket) {\n    socket.disconnect();\n    socket = null;\n    socketListeners = [];\n    reconnectAttempts = 0;\n    console.log('Socket connection closed');\n  }\n};\n\n/**\n * Join a user's personal room for notifications\n * @param {string} userId - The user ID to join\n */\nexport const joinUserRoom = (userId) => {\n  try {\n    const socket = getSocket();\n    socket.emit('joinUserRoom', userId);\n  } catch (error) {\n    console.error('Error joining user room:', error);\n  }\n};\n\n/**\n * Join a ticket room\n * @param {string} ticketId - The ticket ID to join\n */\nexport const joinTicketRoom = (ticketId) => {\n  try {\n    const socket = getSocket();\n    socket.emit('join_ticket', ticketId);\n  } catch (error) {\n    console.error('Error joining ticket room:', error);\n  }\n};\n\n/**\n * Leave a ticket room\n * @param {string} ticketId - The ticket ID to leave\n */\nexport const leaveTicketRoom = (ticketId) => {\n  try {\n    const socket = getSocket();\n    socket.emit('leave_ticket', ticketId);\n  } catch (error) {\n    console.error('Error leaving ticket room:', error);\n  }\n};\n\n/**\n * Join the technician room\n */\nexport const joinTechnicianRoom = () => {\n  try {\n    const socket = getSocket();\n    socket.emit('joinTechnicianRoom');\n  } catch (error) {\n    console.error('Error joining technician room:', error);\n  }\n};\n\n/**\n * Leave the technician room\n */\nexport const leaveTechnicianRoom = () => {\n  try {\n    const socket = getSocket();\n    socket.emit('leaveTechnicianRoom');\n  } catch (error) {\n    console.error('Error leaving technician room:', error);\n  }\n};\n\n/**\n * Send a message to a ticket room\n * @param {Object} data - The message data\n * @returns {Promise} - Resolves when message is sent or rejects on error\n */\nexport const sendTicketMessage = (data) => {\n  return new Promise((resolve, reject) => {\n    try {\n      const socket = getSocket();\n      socket.emit('ticket_message', data);\n      resolve();\n    } catch (error) {\n      console.error('Error sending ticket message:', error);\n      reject(error);\n    }\n  });\n};\n\n/**\n * Accept a ticket as a technician\n * @param {Object} data - The ticket acceptance data\n * @returns {Promise} - Resolves when ticket is accepted or rejects on error\n */\nexport const acceptTicket = (data) => {\n  return new Promise((resolve, reject) => {\n    try {\n      const socket = getSocket();\n      socket.emit('accept_ticket', data);\n      resolve();\n    } catch (error) {\n      console.error('Error accepting ticket:', error);\n      reject(error);\n    }\n  });\n};\n\n/**\n * Check if socket is connected\n * @returns {boolean} - True if socket is connected, false otherwise\n */\nexport const isSocketConnected = () => {\n  return socket && socket.connected;\n};\n\n/**\n * Reconnect the socket if disconnected\n * @param {string} token - Authentication token\n */\nexport const reconnectSocket = (token) => {\n  if (socket && !socket.connected) {\n    socket.connect();\n  } else if (!socket) {\n    getSocket(token);\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}